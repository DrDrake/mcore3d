<?xml version="1.0"?>
<!-- A sample effect definiation xml -->

<root>

<pass
	enable="true"
	drawLine="false"
>
	<standard
		ambient="0.2, 0.2, 0.2, 1.0"
		diffuse="0.8, 0.6, 0.5, 1.0"
		specular="0.5, 0.5, 0.5, 1.0"
		shininess="30.0"
	/>

    <!-- The first occuring texture will use texture unit 0 -->
	<texture
		file="../SpotlightIntensity.jpg"
		shaderName="diffuseMap"
		filter="linear_linear_linear"
	/>
    
	<shader>
		<!-- Reference external file as vertex shader -->
		<vertex>
			<![CDATA[
			varying vec3 vertex, osVertex;
	
			void main()
			{
				osVertex = gl_Vertex.xyz;
				vertex = (gl_Position = ftransform()).xyz;
				
				gl_TexCoord[0] = gl_MultiTexCoord0;
                
                //vec3 vsNormal = gl_NormalMatrix * vec3(gl_Vertex.xy, 0);
                //gl_TexCoord[1].xyz = vsNormal;
			}
			]]>
		</vertex>

		<!-- Define the fragment shader just inside the xml -->
		<fragment>
			<![CDATA[
      uniform sampler2D diffuseMap;
			varying vec3 vertex, osVertex;
			uniform vec3 osCamPos;
			
			vec3 LightIntensity(vec3 pos)
			{
        float lightBoost = 1;//10 * exp(-(5 * pos.z));
        return lightBoost * tex2D(diffuseMap, vec2(length(pos.xy), pos.z)).rgb;
			}
			
			vec3 IntLightIntensity(vec3 start, vec3 end)
			{
				int count = 50;
				vec3 delta = (end - start) / count;
        vec3 q = start;
				vec3 lightInt = vec3(0, 0, 0);
				              
				for(int i = 0; i < count; i++)
				{
					lightInt += LightIntensity(q);
					q += delta;
				}
				return lightInt / count;
			}

			void main()
			{
        // Construct the ray.
        vec3 osRayDir = normalize(osVertex - osCamPos);
				// The cone eqt. used below defines a double cone... so, clamp the cam direcion
				if (osCamPos.z < 0)
        { // osCamPos.z = 0;
          float offsetT = -osCamPos.z / osRayDir.z;
          osCamPos += offsetT * osRayDir;
        }
				
				float backfaceT = length(osVertex - osCamPos);
								
				// Perform ray-cone intersection test.
				// Calculate the frontfaceT from backfaceT.
				// a & c are coff. of the quadratic eqt.
				float a = osRayDir.x * osRayDir.x + osRayDir.y * osRayDir.y - osRayDir.z * osRayDir.z;
				float b = 2 * (osCamPos.x * osRayDir.x + osCamPos.y * osRayDir.y - osCamPos.z * osRayDir.z);
				float c = osCamPos.x * osCamPos.x + osCamPos.y * osCamPos.y - osCamPos.z * osCamPos.z;
				
				float frontfaceT = 0;
				
				if (c > 0) // If c > 0, the camera is outside the infinite cone
				{
                    // Normalize the quadratic eqt.
					b /= a;
					c /= a;
					a = 1;
					
					float rootLarge = (-b + sqrt(b * b - 4 * c)) / 2;
					float rootSmall = (-b - sqrt(b * b - 4 * c)) / 2 ;
					frontfaceT = rootSmall;
					
					if (frontfaceT < 0)
						frontfaceT = rootLarge;
					
					if ((osCamPos + frontfaceT * osRayDir).z < 0) // Move the intersection point on the end cap plane
					{
						frontfaceT = 0;
					}
					
					if ((osCamPos + frontfaceT * osRayDir).z > 1) // Move the intersection point on the end cap plane
					{
						frontfaceT = (1 - osCamPos.z) / osRayDir.z;
					}
				}
				else
				{
					if (osCamPos.z < 1) // If the camera is inside the finite cone
						frontfaceT = 0;
					else // Move the intersection point on the end cap plane
						frontfaceT = (1 - osCamPos.z) / osRayDir.z;
				}
				
				vec3 front = (osCamPos + frontfaceT * osRayDir);
                
        vec3 rayStart = front;
        vec3 rayEnd =   osVertex;
				vec3 lightIntensity = IntLightIntensity(rayStart, rayEnd);
				
				//gl_FragColor.rgb = saturate(lightIntensity * (backfaceT - frontfaceT));
        gl_FragColor.rgb = saturate(lightIntensity);

				gl_FragColor.a = 1;
			}
			]]>
		</fragment>
	</shader>
</pass>

</root>