uniform sampler2DRect texColor;	// Color texture
uniform sampler2DRect texDepth;	// Depth texture
uniform sampler2DRect texNormal;// Normal texture

// We cannot use gl_DepthRange since we are currently rendering the fullscreen quad not the scene
uniform vec2 camerarange = vec2(1.0, 500);

varying vec2 texCoord;

const float aoCap = 1.0;
const float depthTolerance = 0.0001;

float aoMultiplier = 1000.0;

float pw = 1.0;	// Use (1.0 / screensize.x) for GL_TEXTURE2D
float ph = 1.0;

float readDepth(in vec2 coord)
{
	float nearZ = camerarange.x;
	float farZ = camerarange.y;
	float posZ = texture2DRect(texDepth, coord).x;

	return (2.0 * nearZ) / (nearZ + farZ - posZ * (farZ - nearZ));
}

vec3 readNormal(in vec2 coord)
{
	return normalize(2 * (texture2DRect(texNormal, coord).xyz - 1));
}

float compareDepths(in float depth1, in float depth2)
{
	float depthDiff = depth1 - depth2;
	const float aorange = 10.0;	// Units in space the AO effect extends to (this gets divided by the camera far range)
	float diff = clamp(1.0 - depthDiff * (camerarange.y - camerarange.x) / aorange, 0.0, 1.0);
	return min(aoCap, max(0.0, depthDiff) * aoMultiplier) * diff;
}

float calAO(float depth, vec3 normal, float dw, float dh)
{
	vec2 coord = vec2(texCoord.x + dw, texCoord.y + dh);
	float angleFactor = 1 - dot(normal, readNormal(coord));

	if(length(normal) == 0)
		angleFactor = 0;

	return angleFactor * compareDepths(depth, readDepth(coord));
}

void main(void)
{
	float depth = readDepth(texCoord);

	float ao = 0.0;

	vec3 normal = readNormal(texCoord);

	for(int i=0; i<8; ++i)
	{
		ao += calAO(depth, normal, pw, ph);
		ao += calAO(depth, normal, pw, -ph);
		ao += calAO(depth, normal, -pw, ph);
		ao += calAO(depth, normal, -pw, -ph);

		pw *= 1.4;
		ph *= 1.4;
		aoMultiplier /= 1.2;
	}

//	ao *= 2.0;

	gl_FragColor = vec4(1.0 - ao) * texture2DRect(texColor, texCoord);
//	gl_FragColor = texture2DRect(texNormal, texCoord);
}
